
## 1° Texto:
O trecho explica que “programar” e “engenharia de software” não são a mesma coisa. Programar é escrever código, enquanto engenharia de software é aplicar conhecimento e métodos para criar algo real e confiável, assim como engenheiros de outras áreas fazem. A diferença é que, em outras engenharias, existem regras rígidas que precisam ser seguidas para evitar erros graves. Na área de software, isso nem sempre acontece, mas, como os sistemas estão cada vez mais presentes no nosso dia a dia, é necessário adotar práticas mais rigorosas para garantir qualidade e segurança. O livro busca mostrar caminhos para isso.

## 2° Texto: 
O texto explica que engenharia de software não é só escrever código, mas também envolve os métodos e processos usados para manter esse código útil com o passar do tempo. A ideia é criar práticas que deixem o sistema sustentável, ou seja, capaz de se adaptar a mudanças durante todo o seu ciclo de vida — desde a criação até o descarte. O livro apresenta três pontos principais para guiar esse trabalho:

Tempo e mudança — o código precisa se ajustar às necessidades que surgirem ao longo dos anos.<br>
Escala e crescimento — a organização deve evoluir junto com o projeto.<br>
Trocas e custos — as decisões devem considerar os impactos e lições aprendidas com o tempo e o crescimento.


## 3° Exemplos de tradeoffs:

<u><i>Velocidade de entrega vs. Qualidade do código:<br></i></u>
Entregar rápido pode ser bom para lançar logo um produto ou recurso, mas pode significar menos testes e mais erros no futuro. Por outro lado, investir mais tempo em qualidade atrasa a entrega inicial, mas reduz problemas depois.

<u><i>Facilidade de uso vs. Flexibilidade:<br></i></u>
Um sistema simples é fácil para qualquer pessoa usar, mas pode ter menos opções avançadas. Já um sistema muito flexível oferece mais recursos, porém exige mais aprendizado e treinamento.

<u><i>Custo inicial vs. Custo de manutenção:<br></i></u>
Usar soluções mais baratas ou rápidas no começo economiza dinheiro agora, mas pode gerar gastos maiores no futuro para corrigir erros, refatorar código ou atualizar tecnologia.
