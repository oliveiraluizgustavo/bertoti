
## 1° Texto:

O primeiroo trecho do livro "Software Engineering at Google, Oreilly", nos traz a ideia da engenharia de software ser uma área que abrange muito mais aspectos da programação, e não somente a criação de códigos, nos leva a entender que manter o código funcional e sustentável durante anos é tão importante quanto escreve-lo. Aborda o questionamento para as organizações de como implementar técnicas para manter o código valioso por longos períodos. O livro enfatiza três princípios fundamentais quando se esta criando um código, dos quais são, tempo e mudança, escala e crescimento e por ultimo compensações e custos.


## 2° Texto:

O segundo trecho do livro "Software Engineering at Google, Oreilly" tenta criar logo de inicio uma distinção entre engenharia de software da ciência da computação e programação, muitas vezes sendo associadas indistintamente, a engenharia de software tenta passar a ideia de algo mais sério, que aplica um conhecimento teorico para construir algo real e preciso. Diferente das demais engenharias, a de software não cria algo tangível, e sim algo mais teorico. Em contrapartida, as outras engenharias possuem regras rigorosas, pois, erros de cálculo podem trazer sérios danos físicos. Mas, com a integração cada vez mais comum do software em nossas vidas, logo será necessário adotar medidas mais rigorosas de uso.



## 3° Exemplos de tradeoffs:

<u><i>**Negociação de requisitos não funcionais**

Negociação de requisitos não funcionais em Tradeoffs significa aceitar que nem tudo poderá ser entregue em seu máximo, nesse caso, é preciso compensar entre qualidade do sistema de acordo com o que mais agrega valor.

<u><i>**Escalabilidade vs. Simplicidade**

Um sistema altamente escalável costuma exigir arquiteturas distribuídas, mecanismos de cache complexos e bancos de dados fragmentados. Isso garante que ele cresça sem travar, mas torna sua manutenção mais difícil e cara. Já a simplicidade prioriza clareza e facilidade de manutenção, mas pode limitar a capacidade do sistema de suportar um grande volume de usuários ou dados. Assim, quanto mais se busca escalabilidade, mais se sacrifica a simplicidade e vice-versa.


<u><i>**Portabilidade vs. Desempenho**

Um software altamente portátil roda em diferentes sistemas operacionais e dispositivos, mas geralmente depende de camadas de abstração que reduzem a eficiência. Por outro lado, quando o desempenho é prioridade, o código é otimizado para um ambiente específico, explorando ao máximo os recursos de hardware, mas perdendo a flexibilidade de ser executado em outros contextos. Nesse embate, quanto mais portabilidade se busca, mais desempenho se abre mão e o contrário também é verdadeiro.

