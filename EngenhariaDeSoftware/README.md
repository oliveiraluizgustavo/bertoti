# Engenharia de Software

Repositório criado para inserção de atividades solicitadas em classe pelo professor Bertoti, da disciplina de Engenharia de Software.

## 1° ATIVIDADE -  Texto: Software engineering at google trecho 1

O texto mostra bem a diferença entre programar e realmente fazer engenharia de software. Programar é escrever código, mas engenharia de software envolve pensar em todo o processo, na qualidade, na confiabilidade e na manutenção do que é feito. Eu concordo com a ideia de que o software deveria ser tratado com mais rigor, como acontece em outras engenharias, já que hoje ele tem um papel essencial em quase tudo. Também faz sentido o Google ter uma visão própria sobre isso, porque eles lidam com sistemas enormes e precisaram criar métodos mais sólidos para garantir que tudo funcione bem.

## 2° ATIVIDADE -  Texto: Software engineering at google trecho 2

Esse trecho mostra que a engenharia de software vai muito além de apenas escrever código. Ela envolve pensar em como o sistema vai evoluir com o tempo, como a equipe vai crescer e como lidar com as mudanças que sempre acontecem. Achei interessante a ideia de “programar ao longo do tempo”, porque mostra que o objetivo não é só fazer algo que funcione agora, mas algo que continue funcionando e possa ser melhorado depois. Também faz sentido os três princípios que o texto destaca, já que tempo e mudança, escala e crescimento, e os custos e decisões são fatores que realmente influenciam se um software vai continuar sendo útil e sustentável.

## 3° ATIVIDADE -  Exemplos de tradeoffs:

### Compromissos vs. Decisão de troca

Compromissos e decisões de troca acontecem quando precisamos escolher entre dois requisitos que não podem ser totalmente atendidos ao mesmo tempo. Em engenharia de software, isso é comum nos requisitos não funcionais, como desempenho, segurança, custo ou usabilidade. Muitas vezes, melhorar um aspecto significa abrir mão de outro. Por isso, é preciso analisar o que é mais importante para o projeto naquele momento e tomar uma decisão equilibrada. Esses compromissos e decisões de troca fazem parte do processo de construir um sistema sustentável e adequado às necessidades reais.

### Escalabilidade vs. Simplicidade

Escalabilidade e simplicidade são dois requisitos não funcionais que muitas vezes entram em conflito. Quando buscamos que um sistema seja altamente escalável, normalmente precisamos usar arquiteturas mais complexas, com várias camadas, servidores e ferramentas para lidar com grandes volumes de dados ou usuários. Por outro lado, manter o sistema simples facilita o entendimento, a manutenção e o desenvolvimento, mas pode limitar o crescimento no futuro. Então, o trade-off está em encontrar um equilíbrio, deixar o sistema simples o suficiente para ser prático no início, mas planejado para poder escalar quando for necessário.


### Portabilidade vs. Desempenho

Portabilidade e desempenho também costumam gerar um trade-off. Quando buscamos alta portabilidade, queremos que o software funcione bem em diferentes sistemas operacionais ou dispositivos, o que geralmente exige o uso de linguagens e bibliotecas mais genéricas. Isso pode reduzir o desempenho, já que o código não aproveita totalmente os recursos específicos de cada plataforma. Por outro lado, otimizar o desempenho pode exigir soluções mais específicas, que acabam limitando a portabilidade. Por isso, é preciso decidir o que é mais importante para o projeto, ter um sistema rápido em um ambiente específico ou ter um software que rode bem em vários lugares, mesmo que com um pouco menos de performance.

## 4° ATIVIDADE - Classes UML

<img src="/EngenhariaDeSoftware/assets/Diagrama_UML.png">

## 5° ATIVIDADE - Java

## 6° ATIVIDADE - Testes automatizados

## 7° ATIVIDADE - Java -> SQLite

## 8° ATIVIDADE - Usar ollama4j

